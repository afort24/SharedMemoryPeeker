import numpy as npimport posix_ipcimport structimport mmapimport timeimport signalimport sysimport osfrom PyQt5.QtWidgets import (QApplication, QMainWindow, QVBoxLayout, QWidget,                             QTableWidget, QTableWidgetItem, QHeaderView, QLabel,                             QPushButton, QHBoxLayout, QSpinBox, QLabel, QSplitter,                             QComboBox)from PyQt5.QtCore import QTimer, Qt, QThread, pyqtSignal, QRectfrom PyQt5.QtGui import QFont, QColor, QPainter, QPen, QBrush# ConstantsSHM_NAME = "/my_shared_audio_buffer"FLOAT_SIZE = 4RING_BUFFER_SIZE = 8192MAX_CHANNELS = 10  # Updated to support 10 channelsMAX_BUFFER_SIZE = 1024 * 1024  # 1 MB# Global flag to handle clean exitkeep_running = Truedef signal_handler(sig, frame):    global keep_running    print("\nTerminating gracefully...")    keep_running = False    QApplication.quit()# Attach signal handler for SIGINTsignal.signal(signal.SIGINT, signal_handler)class WaveformWidget(QWidget):    """Widget for drawing oscilloscope waveforms"""    def __init__(self, channel_index=0, parent=None):        super().__init__(parent)        self.channel_index = channel_index        self.waveform_data = np.zeros(1024)        self.setMinimumHeight(100)        self.background_color = QColor(0, 0, 0)  # Black background        self.waveform_color = QColor(0, 255, 0)  # Green waveform        self.grid_color = QColor(50, 50, 50)  # Dark gray grid    def update_data(self, data):        """Update the waveform data"""        if data.shape[1] > self.channel_index:            # Get channel data            channel_data = data[:, self.channel_index]            # Roll the existing data and append the new data            new_length = min(len(channel_data), len(self.waveform_data))            self.waveform_data = np.roll(self.waveform_data, -new_length)            self.waveform_data[-new_length:] = channel_data[:new_length]            # Request a repaint            self.update()    def set_channel(self, channel_index):        """Change the channel this widget is displaying"""        self.channel_index = channel_index        # Clear waveform data to avoid displaying wrong channel data momentarily        self.waveform_data = np.zeros(1024)        self.update()    def paintEvent(self, event):        painter = QPainter(self)        painter.setRenderHint(QPainter.Antialiasing)        # Draw background        painter.fillRect(self.rect(), self.background_color)        # Draw grid        painter.setPen(QPen(self.grid_color, 1))        # Vertical grid lines        grid_spacing = 50        for x in range(0, self.width(), grid_spacing):            painter.drawLine(x, 0, x, self.height())        # Horizontal grid lines        painter.drawLine(0, self.height() // 2, self.width(), self.height() // 2)  # Center line        for y in range(0, self.height(), grid_spacing):            painter.drawLine(0, y, self.width(), y)        # Draw waveform        if len(self.waveform_data) > 1:            painter.setPen(QPen(self.waveform_color, 2))  # Thicker line            # Scale the data to fit the widget            h = self.height()            w = self.width()            center_y = h // 2            scale_y = h // 3  # Scale to use 2/3 of the height            # Calculate min/max for scaling            data_min = np.min(self.waveform_data)            data_max = np.max(self.waveform_data)            data_range = max(0.001, data_max - data_min)            # Draw points connected by lines            points_per_pixel = max(1, len(self.waveform_data) // w)            prev_y = None            for i in range(w):                # Get data for this pixel                start_idx = i * points_per_pixel                end_idx = min((i + 1) * points_per_pixel, len(self.waveform_data))                if start_idx >= len(self.waveform_data):                    break                # Use min/max to capture full range                chunk = self.waveform_data[start_idx:end_idx]                if len(chunk) > 0:                    min_val = np.min(chunk)                    max_val = np.max(chunk)                    avg_val = np.mean(chunk)                    # Calculate y positions                    y_min = center_y - int(min_val * scale_y)                    y_max = center_y - int(max_val * scale_y)                    y_avg = center_y - int(avg_val * scale_y)                    # Draw vertical line for range                    if y_min != y_max:                        painter.drawLine(i, y_min, i, y_max)                    # Connect to previous point                    if prev_y is not None:                        painter.drawLine(i - 1, prev_y, i, y_avg)                    prev_y = y_avg        # Draw channel label and stats        painter.setPen(QColor(0, 255, 0))        painter.setFont(QFont('Arial', 10))        min_val = round(np.min(self.waveform_data), 3)        max_val = round(np.max(self.waveform_data), 3)        channel_text = f"Channel {self.channel_index + 1} [Min:{min_val}, Max:{max_val}]"        painter.drawText(10, 20, channel_text)class AudioDataReader(QThread):    """Thread for reading audio data from shared memory"""    dataReady = pyqtSignal(np.ndarray, int, int)  # Data, write index, channels    memoryDump = pyqtSignal(list)  # For hex dump display    connectionStatus = pyqtSignal(bool, str)  # Connected status and message    def __init__(self, parent=None):        super().__init__(parent)        self.running = True        self.debug_offset = 0  # Starting memory offset for debugging        self.connected = False        self.shm = None        self.map_file = None        self.write_index_offset = 0        self.num_channels_offset = 20        self.audio_data_offset = 64        self.num_channels = MAX_CHANNELS  # Default assumption matches MAX_CHANNELS        # Initialize with dummy data        self.dummy_data = np.zeros((256, MAX_CHANNELS))    def connect_to_shared_memory(self):        """Try to connect to shared memory"""        try:            # Clean up any existing connection            if self.map_file:                self.map_file.close()                self.map_file = None            if self.shm:                self.shm.close_fd()                self.shm = None            # Attempt to connect            self.shm = posix_ipc.SharedMemory(SHM_NAME, flags=0)            self.map_file = mmap.mmap(self.shm.fd, MAX_BUFFER_SIZE, mmap.MAP_SHARED, mmap.PROT_READ)            self.shm.close_fd()            # Parse header once connected            self.parse_memory_header()            self.connected = True            self.connectionStatus.emit(True, "Connected to shared memory")            print("Successfully connected to shared memory")            return True        except Exception as e:            self.connected = False            self.connectionStatus.emit(False, f"Waiting for shared memory: {e}")            return False    def parse_memory_header(self):        """Parse header information from the memory dump"""        if not self.map_file:            return        # Read the first 64 bytes of memory        self.map_file.seek(0)        header = self.map_file.read(64)        # Analyze and print what we find        print("\nParsing shared memory header:")        # First 8 bytes appear to be the write index (or related)        self.write_index_offset = 0        write_index = struct.unpack("Q", header[0:8])[0]        print(f"Offset 0: Value {write_index} (possible write index)")        # Bytes 16-20 seem to have value 1        value_at_16 = struct.unpack("i", header[16:20])[0]        print(f"Offset 16: Value {value_at_16}")        # Bytes 20-24 seem to have value 2 - could be num_channels        self.num_channels_offset = 20        num_channels = struct.unpack("i", header[20:24])[0]        print(f"Offset 20: Value {num_channels} (possible channel count)")        # Try to determine where the audio data starts        # From hex dump, after the first 64 bytes, it's mostly zeros        self.audio_data_offset = 64        print(f"Assuming audio data starts at offset {self.audio_data_offset}")        # Send a full hex dump for display        self.update_memory_dump()    def update_memory_dump(self):        """Read a section of memory for hex dump display"""        if not self.map_file:            # Send empty hex dump if not connected            self.memoryDump.emit(["00"] * 256)            return        try:            self.map_file.seek(self.debug_offset)            memory_block = self.map_file.read(256)  # Read 256 bytes            hex_values = [f"{b:02x}" for b in memory_block]            # Find actual number of channels            self.map_file.seek(self.num_channels_offset)            self.num_channels = struct.unpack("i", self.map_file.read(4))[0]            # Ensure number of channels is within bounds            self.num_channels = min(MAX_CHANNELS, max(1, self.num_channels))            # Send the dump to the UI            self.memoryDump.emit(hex_values)        except Exception as e:            print(f"Error in update_memory_dump: {e}")            # Send empty hex dump on error            self.memoryDump.emit(["00"] * 256)    def run(self):        print("AudioDataReader thread started")        retry_counter = 0        retry_interval = 1.0  # Start with 1 second retry        while self.running and keep_running:            try:                # If not connected, try to connect                if not self.connected:                    retry_counter += 1                    if self.connect_to_shared_memory():                        retry_counter = 0                        retry_interval = 1.0                    else:                        # Send dummy data when not connected                        if retry_counter % 10 == 0:  # Every 10 retries only to reduce log spam                            print(f"Waiting for shared memory... (retry {retry_counter})")                        # Emit dummy data with small random noise for visual feedback                        noise = np.random.random(self.dummy_data.shape) * 0.05 - 0.025                        self.dataReady.emit(self.dummy_data + noise, 0, MAX_CHANNELS)                        # Gradually increase retry interval up to 5 seconds                        retry_interval = min(5.0, retry_interval * 1.1)                        time.sleep(retry_interval)                        continue                # Update memory dump occasionally                if np.random.random() < 0.2:  # 20% chance each cycle                    self.update_memory_dump()                # Read the raw data                data, write_index, num_channels = self.read_audio_data_raw()                if data is not None:                    self.dataReady.emit(data, write_index, num_channels)            except posix_ipc.ExistentialError:                # Shared memory was removed                print("Shared memory no longer exists, waiting for it to be recreated...")                self.connected = False                self.connectionStatus.emit(False, "Shared memory disconnected")                if self.map_file:                    self.map_file.close()                    self.map_file = None            except Exception as e:                print(f"Error in reader thread: {e}")                import traceback                traceback.print_exc()            time.sleep(0.05)  # Update rate (20 Hz for smoother oscilloscope)    def read_audio_data_raw(self):        if not self.connected or not self.map_file:            return self.dummy_data, 0, MAX_CHANNELS        try:            # Read write index            self.map_file.seek(self.write_index_offset)            write_index_bytes = self.map_file.read(8)            if len(write_index_bytes) < 8:                return self.dummy_data, 0, MAX_CHANNELS            write_index = struct.unpack("Q", write_index_bytes)[0]            # Read number of channels            self.map_file.seek(self.num_channels_offset)            channel_bytes = self.map_file.read(4)            if len(channel_bytes) < 4:                return self.dummy_data, write_index, MAX_CHANNELS            num_channels = struct.unpack("i", channel_bytes)[0]            num_channels = min(MAX_CHANNELS, max(1, num_channels))  # Ensure reasonable range            # Calculate where to read the most recent frames            frames_to_read = 256  # Read more frames for oscilloscope            # Based on hex dump, the buffer might be very small            # or the write index approach might need adjustment            current_pos = write_index % RING_BUFFER_SIZE            start_frame = max(0, current_pos - frames_to_read)            # Create result array with proper shape for MAX_CHANNELS            result = np.zeros((frames_to_read, MAX_CHANNELS))            # Try reading raw bytes first for diagnostic            self.map_file.seek(self.audio_data_offset)            raw_data = self.map_file.read(1024)  # Read some raw data            if all(b == 0 for b in raw_data):                # If all zeros, the audio data hasn't been written yet                return result, write_index, num_channels            # Read each frame individually            for i in range(frames_to_read):                frame_index = (start_frame + i) % RING_BUFFER_SIZE                offset = self.audio_data_offset + frame_index * num_channels * FLOAT_SIZE                if offset + (num_channels * FLOAT_SIZE) > MAX_BUFFER_SIZE:                    continue  # Skip if would read beyond buffer                # Read all channels in this frame                self.map_file.seek(offset)                frame_bytes = self.map_file.read(FLOAT_SIZE * num_channels)                if len(frame_bytes) < FLOAT_SIZE * num_channels:                    continue                # Extract each channel value                for ch in range(num_channels):                    start_idx = ch * FLOAT_SIZE                    end_idx = start_idx + FLOAT_SIZE                    try:                        if start_idx < len(frame_bytes) and end_idx <= len(frame_bytes):                            value = struct.unpack("f", frame_bytes[start_idx:end_idx])[0]                            result[i, ch] = value                    except Exception as e:                        print(f"Error unpacking channel {ch}: {e}")            return result, write_index, num_channels        except Exception as e:            print(f"Error reading audio data: {e}")            import traceback            traceback.print_exc()            # On error, disconnect and return dummy data            self.connected = False            self.connectionStatus.emit(False, f"Connection error: {e}")            return self.dummy_data, 0, MAX_CHANNELS    def set_debug_offset(self, offset):        """Set the memory offset for debugging"""        self.debug_offset = offset        self.update_memory_dump()    def stop(self):        self.running = False        self.wait()        if hasattr(self, 'map_file') and self.map_file:            self.map_file.close()class AudioBufferMonitor(QMainWindow):    """Main window for displaying raw buffer data"""    def __init__(self):        super().__init__()        self.setWindowTitle("Audio Buffer Monitor with Oscilloscope")        self.setMinimumSize(1000, 800)        # Data freeze state        self.freeze_active = False        self.frozen_data = None        self.frozen_write_index = 0        self.frozen_num_channels = 0        # Main layout with splitter        self.main_splitter = QSplitter(Qt.Vertical)        # Top widget for oscilloscope        oscilloscope_widget = QWidget()        oscilloscope_layout = QVBoxLayout(oscilloscope_widget)        # Header with info, channel selectors, and freeze button        header_layout = QVBoxLayout()  # Change to vertical layout        # Top row with connection status        status_row = QHBoxLayout()        self.connection_label = QLabel("Status: Waiting for shared memory...")        self.connection_label.setStyleSheet("color: #FFA500; font-weight: bold;")  # Orange color        status_row.addWidget(self.connection_label)        status_row.addStretch()  # Push everything to the left        header_layout.addLayout(status_row)        # Second row with info label        info_row = QHBoxLayout()        self.info_label = QLabel("Waiting for data...")        self.info_label.setAlignment(Qt.AlignLeft)  # Explicitly set left alignment        info_row.addWidget(self.info_label)        info_row.addStretch()  # Push everything to the left        header_layout.addLayout(info_row)        # Third row with channel selectors and freeze button        controls_row = QHBoxLayout()        controls_row.addStretch()  # This pushes the controls to the right        # Waveform 1 channel selector        controls_row.addWidget(QLabel("Waveform 1:"))        self.channel1_selector = QComboBox()        self.channel1_selector.setFixedWidth(120)  # Wider dropdown        for i in range(MAX_CHANNELS):            self.channel1_selector.addItem(f"Channel {i + 1}")        self.channel1_selector.setCurrentIndex(0)        self.channel1_selector.currentIndexChanged.connect(self.change_waveform1_channel)        controls_row.addWidget(self.channel1_selector)        # Waveform 2 channel selector        controls_row.addWidget(QLabel("Waveform 2:"))        self.channel2_selector = QComboBox()        self.channel2_selector.setFixedWidth(120)  # Wider dropdown        for i in range(MAX_CHANNELS):            self.channel2_selector.addItem(f"Channel {i + 1}")        self.channel2_selector.setCurrentIndex(1)        self.channel2_selector.currentIndexChanged.connect(self.change_waveform2_channel)        controls_row.addWidget(self.channel2_selector)        # Freeze toggle button        self.freeze_button = QPushButton("Freeze")        self.freeze_button.setCheckable(True)  # Make it a toggle button        self.freeze_button.setFixedWidth(100)  # Fixed width        self.freeze_button.clicked.connect(self.toggle_freeze)        self.freeze_button.setStyleSheet("""            QPushButton {                background-color: #3F51B5;                color: white;                border-radius: 4px;                padding: 5px;                font-weight: bold;            }            QPushButton:checked {                background-color: #F44336;            }            QPushButton:hover {                background-color: #5C6BC0;            }            QPushButton:checked:hover {                background-color: #EF5350;            }        """)        controls_row.addWidget(self.freeze_button)        header_layout.addLayout(controls_row)        # Add the entire header layout to the oscilloscope layout        oscilloscope_layout.addLayout(header_layout)        # Create two waveform widgets (for stereo)        self.waveform1 = WaveformWidget(channel_index=0)        self.waveform2 = WaveformWidget(channel_index=1)        oscilloscope_layout.addWidget(self.waveform1)        oscilloscope_layout.addWidget(self.waveform2)        # Stats label        self.stats_label = QLabel("Buffer Stats: None")        oscilloscope_layout.addWidget(self.stats_label)        # Bottom widget for table and hex view        data_widget = QWidget()        data_layout = QVBoxLayout(data_widget)        # Create table for raw data display        self.data_table = QTableWidget(16, MAX_CHANNELS + 1)  # +1 for frame index        self.data_table.setHorizontalHeaderItem(0, QTableWidgetItem("Frame"))        for ch in range(MAX_CHANNELS):            self.data_table.setHorizontalHeaderItem(ch + 1, QTableWidgetItem(f"Ch {ch + 1}"))        # Set table properties        self.data_table.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)        self.data_table.setAlternatingRowColors(True)        font = QFont("Courier", 10)  # Use Courier instead of Monospace        self.data_table.setFont(font)        data_layout.addWidget(self.data_table)        # Hex dump for debugging        dump_layout = QVBoxLayout()        dump_header = QHBoxLayout()        dump_header.addWidget(QLabel("Memory Hex Dump:"))        # Offset selector        dump_header.addWidget(QLabel("Offset:"))        self.offset_spinner = QSpinBox()        self.offset_spinner.setRange(0, MAX_BUFFER_SIZE - 256)        self.offset_spinner.setSingleStep(16)        self.offset_spinner.valueChanged.connect(self.change_debug_offset)        dump_header.addWidget(self.offset_spinner)        dump_header.addStretch()        dump_layout.addLayout(dump_header)        # Hex dump display        self.hex_dump = QTableWidget(16, 16)        self.hex_dump.setFont(font)        self.hex_dump.verticalHeader().setVisible(True)        self.hex_dump.setMaximumHeight(200)        # Set hex dump header (0-F)        for i in range(16):            self.hex_dump.setHorizontalHeaderItem(i, QTableWidgetItem(f"{i:X}"))        dump_layout.addWidget(self.hex_dump)        data_layout.addLayout(dump_layout)        # Add widgets to splitter        self.main_splitter.addWidget(oscilloscope_widget)        self.main_splitter.addWidget(data_widget)        # Set relative sizes (60% oscilloscope, 40% data table)        self.main_splitter.setSizes([600, 400])        # Set main splitter as central widget        self.setCentralWidget(self.main_splitter)        # Set dark theme        self.setStyleSheet("""            QMainWindow, QWidget {                background-color: #212121;                color: #FFFFFF;            }            QTableWidget {                background-color: #333333;                alternate-background-color: #3a3a3a;                color: #EEEEEE;                gridline-color: #444444;                selection-background-color: #4444AA;            }            QHeaderView::section {                background-color: #444444;                color: #FFFFFF;                padding: 4px;                border: 1px solid #555555;            }            QLabel {                color: #FFFFFF;                font-size: 12px;            }            QSpinBox, QComboBox {                background-color: #333333;                color: #FFFFFF;                border: 1px solid #555555;                padding: 2px 8px;            }            QComboBox::drop-down {                border: 0px;            }            QComboBox QAbstractItemView {                background-color: #444444;                color: #FFFFFF;                selection-background-color: #4444AA;            }            QSplitter::handle {                background-color: #444444;            }        """)        # Start the data reader thread        self.data_reader = AudioDataReader()        self.data_reader.dataReady.connect(self.update_all)        self.data_reader.memoryDump.connect(self.update_hex_dump)        self.data_reader.connectionStatus.connect(self.update_connection_status)        self.data_reader.start()        # Last update time for FPS calculation        self.last_update_time = time.time()        self.updates_count = 0    def change_waveform1_channel(self, index):        """Change which channel is displayed in waveform 1"""        self.waveform1.set_channel(index)    def change_waveform2_channel(self, index):        """Change which channel is displayed in waveform 2"""        self.waveform2.set_channel(index)    def update_connection_status(self, connected, message):        """Update the connection status label"""        if connected:            self.connection_label.setText(f"Status: {message}")            self.connection_label.setStyleSheet("color: #00FF00; font-weight: bold;")  # Green for connected        else:            self.connection_label.setText(f"Status: {message}")            self.connection_label.setStyleSheet("color: #FFA500; font-weight: bold;")  # Orange for disconnected    def toggle_freeze(self, checked):        """Toggle the freeze state of the display"""        self.freeze_active = checked        if checked:            self.freeze_button.setText("Unfreeze")            # Store current values when freezing            if self.frozen_data is not None:                self.info_label.setText(f"FROZEN - Write Index: {self.frozen_write_index} | " +                                        f"Channels: {self.frozen_num_channels}")        else:            self.freeze_button.setText("Freeze")            # Clear the frozen state            self.frozen_data = None    def update_all(self, data, write_index, num_channels):        """Update all displays with new data"""        self.updates_count += 1        # If freeze is active, store the data only the first time        if self.freeze_active:            if self.frozen_data is None:                # Store a copy of the data                self.frozen_data = data.copy()                self.frozen_write_index = write_index                self.frozen_num_channels = num_channels                # Update displays with frozen data                self.waveform1.update_data(self.frozen_data)                self.waveform2.update_data(self.frozen_data)                # Update table with only the most recent frames                table_frames = self.frozen_data[-16:] if self.frozen_data.shape[0] >= 16 else self.frozen_data                self.update_table(table_frames, self.frozen_write_index, self.frozen_num_channels)                # Calculate statistics for frozen data                data_min = np.min(self.frozen_data)                data_max = np.max(self.frozen_data)                data_mean = np.mean(self.frozen_data)                data_std = np.std(self.frozen_data)                self.stats_label.setText(                    f"FROZEN - Buffer Stats: Min={data_min:.6f}, Max={data_max:.6f}, Mean={data_mean:.6f}, StdDev={data_std:.6f}")            # Return early if freeze is active - don't update with new data            return        # Update oscilloscope        self.waveform1.update_data(data)        self.waveform2.update_data(data)        # Update table with only the most recent frames        table_frames = data[-16:] if data.shape[0] >= 16 else data        self.update_table(table_frames, write_index, num_channels)        # Update info label        current_time = time.time()        elapsed = current_time - self.last_update_time        if elapsed >= 1.0:            fps = self.updates_count / elapsed            self.info_label.setText(f"Write Index: {write_index} | Channels: {num_channels} | Updates: {fps:.1f}/sec")            self.last_update_time = current_time            self.updates_count = 0        # Calculate statistics        data_min = np.min(data)        data_max = np.max(data)        data_mean = np.mean(data)        data_std = np.std(data)        self.stats_label.setText(            f"Buffer Stats: Min={data_min:.6f}, Max={data_max:.6f}, Mean={data_mean:.6f}, StdDev={data_std:.6f}")    def update_table(self, data, write_index, num_channels):        """Update the table with new data"""        # Populate table with data        num_frames = min(16, data.shape[0])        for row in range(num_frames):            # Frame index            frame_idx = write_index - num_frames + row            frame_item = QTableWidgetItem(str(frame_idx))            self.data_table.setItem(row, 0, frame_item)            # Channel data            for col in range(min(MAX_CHANNELS, data.shape[1])):                value = data[row, col]                item = QTableWidgetItem(f"{value:.6f}")                # Color code based on value                if abs(value) > 0.9:                    # Near clipping                    item.setBackground(QColor(230, 80, 80))                elif abs(value) > 0.01:                    # Normal signal                    item.setBackground(QColor(80, 180, 80))                self.data_table.setItem(row, col + 1, item)    def update_hex_dump(self, hex_values):        """Update the hex dump display"""        # If freeze is active, don't update hex dump        if self.freeze_active:            return        # Clear the table        for row in range(16):            for col in range(16):                index = row * 16 + col                if index < len(hex_values):                    item = QTableWidgetItem(hex_values[index])                    # Color non-zero values differently                    if hex_values[index] != "00":                        item.setBackground(QColor(100, 150, 200))                    self.hex_dump.setItem(row, col, item)                else:                    self.hex_dump.setItem(row, col, QTableWidgetItem(""))        # Update the address labels        for row in range(16):            addr = self.offset_spinner.value() + row * 16            self.hex_dump.setVerticalHeaderItem(row, QTableWidgetItem(f"{addr:04X}"))    def change_debug_offset(self, value):        """Change the memory offset for debugging"""        if hasattr(self, 'data_reader'):            self.data_reader.set_debug_offset(value)    def closeEvent(self, event):        """Handle window close event"""        self.data_reader.stop()        event.accept()def main():    app = QApplication(sys.argv)    window = AudioBufferMonitor()    window.show()    # Start the event loop    exit_code = app.exec_()    # Cleanup    print("Application closed")    sys.exit(exit_code)if __name__ == "__main__":    main()